# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

input AddNotificationsToUserInput {
  """The id of the record."""
  id: ID!

  """The ids of the relations."""
  relationIds: [ID!]!
}

input AddRolesToUserInput {
  """The id of the record."""
  id: ID!

  """The ids of the relations."""
  relationIds: [ID!]!
}

input AuthInput {
  email: String!
  password: String!
}

type AuthType {
  token: String!
  user: User!
}

input CreateFieldInput {
  acre: String
  cordinates: String
  imagePath: String
  name: String!
}

input CreateFieldSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: FieldSubscriptionFilter!
}

input CreateFileInput {
  fileName: String
  filePath: String
  id: String
  name: String
  path: String
}

input CreateInventoryInput {
  amount: Float!
  fields: [UpdateFieldInput!]
  name: String
  provider: String
  storage: String
  storages: [UpdateStorageInput!]
  value: Float
}

input CreateManyFilesInput {
  """Array of records to create"""
  files: [CreateFileInput!]!
}

input CreateManyInventoriesInput {
  """Array of records to create"""
  inventories: [CreateInventoryInput!]!
}

input CreateManyNotificationsInput {
  """Array of records to create"""
  notifications: [CreateNotification!]!
}

input CreateManyProductionsInput {
  """Array of records to create"""
  productions: [CreateProductionInput!]!
}

input CreateManyStoragesInput {
  """Array of records to create"""
  storages: [CreateStorageInput!]!
}

input CreateManyTasksInput {
  """Array of records to create"""
  tasks: [CreateTaskInput!]!
}

input CreateManyUsersInput {
  """Array of records to create"""
  users: [CreateUserInput!]!
}

input CreateNotification {
  description: String
  id: String
  title: String
  userId: String
}

input CreateOneFileInput {
  """The record to create"""
  file: CreateFileInput!
}

input CreateOneInventoryInput {
  """The record to create"""
  inventory: CreateInventoryInput!
}

input CreateOneNotificationInput {
  """The record to create"""
  notification: CreateNotification!
}

input CreateOneProductionInput {
  """The record to create"""
  production: CreateProductionInput!
}

input CreateOneStorageInput {
  """The record to create"""
  storage: CreateStorageInput!
}

input CreateOneTaskInput {
  """The record to create"""
  task: CreateTaskInput!
}

input CreateOneUserInput {
  """The record to create"""
  user: CreateUserInput!
}

input CreateProductionInput {
  amount: Float!
  fields: [UpdateFieldInput!]
  name: String!
}

input CreateStorageInput {
  amount: Float!
  name: String!
}

input CreateTaskInput {
  date: DateTime!
  dayOfWeek: Float
  description: String!
  title: String!
  userName: String
}

input CreateUserInput {
  CPF: String
  email: String!
  name: String!
  password: String!
  roles: [RoleInput!]!
  telephone: String
}

input DateFieldComparison {
  between: DateFieldComparisonBetween
  eq: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  is: Boolean
  isNot: Boolean
  lt: DateTime
  lte: DateTime
  neq: DateTime
  notBetween: DateFieldComparisonBetween
  notIn: [DateTime!]
}

input DateFieldComparisonBetween {
  lower: DateTime!
  upper: DateTime!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

input DeleteManyFilesInput {
  """Filter to find records to delete"""
  filter: FileDeleteFilter!
}

input DeleteManyInventoriesInput {
  """Filter to find records to delete"""
  filter: InventoryDeleteFilter!
}

input DeleteManyNotificationsInput {
  """Filter to find records to delete"""
  filter: NotificationDeleteFilter!
}

input DeleteManyProductionsInput {
  """Filter to find records to delete"""
  filter: ProductionDeleteFilter!
}

type DeleteManyResponse {
  """The number of records deleted."""
  deletedCount: Int!
}

input DeleteManyStoragesInput {
  """Filter to find records to delete"""
  filter: StorageDeleteFilter!
}

input DeleteManyTasksInput {
  """Filter to find records to delete"""
  filter: TaskDeleteFilter!
}

input DeleteManyUsersInput {
  """Filter to find records to delete"""
  filter: UserDeleteFilter!
}

input DeleteOneFieldSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: FieldSubscriptionFilter!
}

input DeleteOneFileInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteOneInventoryInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteOneNotificationInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteOneProductionInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteOneStorageInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteOneTaskInput {
  """The id of the record to delete."""
  id: ID!
}

input DeleteOneUserInput {
  """The id of the record to delete."""
  id: ID!
}

type Field {
  acre: String!
  cordinates: String
  createdAt: DateTime!
  deletedAt: DateTime!
  fieldImage: File
  id: String!
  imagePath: String
  inventories: Inventory
  name: String!
  productions: Production
  updatedAt: DateTime!
}

input FieldAggregateFilter {
  acre: StringFieldComparison
  and: [FieldAggregateFilter!]
  cordinates: StringFieldComparison
  createdAt: DateFieldComparison
  deletedAt: DateFieldComparison
  id: StringFieldComparison
  imagePath: StringFieldComparison
  name: StringFieldComparison
  or: [FieldAggregateFilter!]
  updatedAt: DateFieldComparison
}

type FieldAggregateGroupBy {
  acre: String
  cordinates: String
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  imagePath: String
  name: String
  updatedAt: DateTime
}

type FieldAggregateResponse {
  count: FieldCountAggregate
  groupBy: FieldAggregateGroupBy
  max: FieldMaxAggregate
  min: FieldMinAggregate
}

type FieldConnection {
  """Array of nodes."""
  nodes: [Field!]!

  """Paging information"""
  pageInfo: OffsetPageInfo!
}

type FieldCountAggregate {
  acre: Int
  cordinates: Int
  createdAt: Int
  deletedAt: Int
  id: Int
  imagePath: Int
  name: Int
  updatedAt: Int
}

type FieldDeleteResponse {
  acre: String
  cordinates: String
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  imagePath: String
  name: String
  updatedAt: DateTime
}

input FieldFilter {
  acre: StringFieldComparison
  and: [FieldFilter!]
  cordinates: StringFieldComparison
  createdAt: DateFieldComparison
  deletedAt: DateFieldComparison
  fieldImage: FieldFilterFileFilter
  id: StringFieldComparison
  imagePath: StringFieldComparison
  inventories: FieldFilterInventoryFilter
  name: StringFieldComparison
  or: [FieldFilter!]
  productions: FieldFilterProductionFilter
  updatedAt: DateFieldComparison
}

input FieldFilterFileFilter {
  and: [FieldFilterFileFilter!]
  createdAt: DateFieldComparison
  deletedAt: DateFieldComparison
  id: StringFieldComparison
  name: StringFieldComparison
  or: [FieldFilterFileFilter!]
  updatedAt: DateFieldComparison
}

input FieldFilterInventoryFilter {
  amount: NumberFieldComparison
  and: [FieldFilterInventoryFilter!]
  createdAt: DateFieldComparison
  deletedAt: DateFieldComparison
  id: StringFieldComparison
  name: StringFieldComparison
  or: [FieldFilterInventoryFilter!]
  provider: StringFieldComparison
  storage: StringFieldComparison
  updatedAt: DateFieldComparison
  value: NumberFieldComparison
}

input FieldFilterProductionFilter {
  amount: NumberFieldComparison
  and: [FieldFilterProductionFilter!]
  createdAt: DateFieldComparison
  deletedAt: DateFieldComparison
  id: StringFieldComparison
  name: StringFieldComparison
  or: [FieldFilterProductionFilter!]
  updatedAt: DateFieldComparison
}

type FieldMaxAggregate {
  acre: String
  cordinates: String
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  imagePath: String
  name: String
  updatedAt: DateTime
}

type FieldMinAggregate {
  acre: String
  cordinates: String
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  imagePath: String
  name: String
  updatedAt: DateTime
}

input FieldSort {
  direction: SortDirection!
  field: FieldSortFields!
  nulls: SortNulls
}

enum FieldSortFields {
  acre
  cordinates
  createdAt
  deletedAt
  id
  imagePath
  name
  updatedAt
}

input FieldSubscriptionFilter {
  acre: StringFieldComparison
  and: [FieldSubscriptionFilter!]
  cordinates: StringFieldComparison
  createdAt: DateFieldComparison
  deletedAt: DateFieldComparison
  id: StringFieldComparison
  imagePath: StringFieldComparison
  name: StringFieldComparison
  or: [FieldSubscriptionFilter!]
  updatedAt: DateFieldComparison
}

type File {
  createdAt: DateTime!
  deletedAt: DateTime!
  fileName: String
  filePath: String
  id: String!
  name: String
  path: String
  updatedAt: DateTime!
}

type FileAggregateGroupBy {
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  name: String
  updatedAt: DateTime
}

type FileConnection {
  """Array of nodes."""
  nodes: [File!]!

  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type FileCountAggregate {
  createdAt: Int
  deletedAt: Int
  id: Int
  name: Int
  updatedAt: Int
}

input FileDeleteFilter {
  and: [FileDeleteFilter!]
  createdAt: DateFieldComparison
  deletedAt: DateFieldComparison
  id: StringFieldComparison
  name: StringFieldComparison
  or: [FileDeleteFilter!]
  updatedAt: DateFieldComparison
}

type FileDeleteResponse {
  createdAt: DateTime
  deletedAt: DateTime
  fileName: String
  filePath: String
  id: String
  name: String
  path: String
  updatedAt: DateTime
}

input FileFilter {
  and: [FileFilter!]
  createdAt: DateFieldComparison
  deletedAt: DateFieldComparison
  id: StringFieldComparison
  name: StringFieldComparison
  or: [FileFilter!]
  updatedAt: DateFieldComparison
}

type FileMaxAggregate {
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  name: String
  updatedAt: DateTime
}

type FileMinAggregate {
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  name: String
  updatedAt: DateTime
}

input FileSort {
  direction: SortDirection!
  field: FileSortFields!
  nulls: SortNulls
}

enum FileSortFields {
  createdAt
  deletedAt
  id
  name
  updatedAt
}

input FileUpdateFilter {
  and: [FileUpdateFilter!]
  createdAt: DateFieldComparison
  deletedAt: DateFieldComparison
  id: StringFieldComparison
  name: StringFieldComparison
  or: [FileUpdateFilter!]
  updatedAt: DateFieldComparison
}

type Inventory {
  amount: Float!
  createdAt: DateTime!
  deletedAt: DateTime!
  fields: Field
  id: String!
  name: String!
  provider: String!
  storage: String
  storages: Storage
  updatedAt: DateTime!
  value: Float
}

type InventoryAggregateGroupBy {
  amount: Float
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  name: String
  provider: String
  storage: String
  updatedAt: DateTime
  value: Float
}

type InventoryAvgAggregate {
  amount: Float
  value: Float
}

type InventoryConnection {
  """Array of nodes."""
  nodes: [Inventory!]!

  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type InventoryCountAggregate {
  amount: Int
  createdAt: Int
  deletedAt: Int
  id: Int
  name: Int
  provider: Int
  storage: Int
  updatedAt: Int
  value: Int
}

input InventoryDeleteFilter {
  amount: NumberFieldComparison
  and: [InventoryDeleteFilter!]
  createdAt: DateFieldComparison
  deletedAt: DateFieldComparison
  id: StringFieldComparison
  name: StringFieldComparison
  or: [InventoryDeleteFilter!]
  provider: StringFieldComparison
  storage: StringFieldComparison
  updatedAt: DateFieldComparison
  value: NumberFieldComparison
}

type InventoryDeleteResponse {
  amount: Float
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  name: String
  provider: String
  storage: String
  updatedAt: DateTime
  value: Float
}

input InventoryFilter {
  amount: NumberFieldComparison
  and: [InventoryFilter!]
  createdAt: DateFieldComparison
  deletedAt: DateFieldComparison
  fields: InventoryFilterFieldFilter
  id: StringFieldComparison
  name: StringFieldComparison
  or: [InventoryFilter!]
  provider: StringFieldComparison
  storage: StringFieldComparison
  storages: InventoryFilterStorageFilter
  updatedAt: DateFieldComparison
  value: NumberFieldComparison
}

input InventoryFilterFieldFilter {
  acre: StringFieldComparison
  and: [InventoryFilterFieldFilter!]
  cordinates: StringFieldComparison
  createdAt: DateFieldComparison
  deletedAt: DateFieldComparison
  id: StringFieldComparison
  imagePath: StringFieldComparison
  name: StringFieldComparison
  or: [InventoryFilterFieldFilter!]
  updatedAt: DateFieldComparison
}

input InventoryFilterStorageFilter {
  amount: NumberFieldComparison
  and: [InventoryFilterStorageFilter!]
  createdAt: DateFieldComparison
  deletedAt: DateFieldComparison
  id: StringFieldComparison
  name: StringFieldComparison
  or: [InventoryFilterStorageFilter!]
  updatedAt: DateFieldComparison
}

type InventoryMaxAggregate {
  amount: Float
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  name: String
  provider: String
  storage: String
  updatedAt: DateTime
  value: Float
}

type InventoryMinAggregate {
  amount: Float
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  name: String
  provider: String
  storage: String
  updatedAt: DateTime
  value: Float
}

input InventorySort {
  direction: SortDirection!
  field: InventorySortFields!
  nulls: SortNulls
}

enum InventorySortFields {
  amount
  createdAt
  deletedAt
  id
  name
  provider
  storage
  updatedAt
  value
}

type InventorySumAggregate {
  amount: Float
  value: Float
}

input InventoryUpdateFilter {
  amount: NumberFieldComparison
  and: [InventoryUpdateFilter!]
  createdAt: DateFieldComparison
  deletedAt: DateFieldComparison
  id: StringFieldComparison
  name: StringFieldComparison
  or: [InventoryUpdateFilter!]
  provider: StringFieldComparison
  storage: StringFieldComparison
  updatedAt: DateFieldComparison
  value: NumberFieldComparison
}

type Mutation {
  addNotificationsToUser(input: AddNotificationsToUserInput!): User!
  addRolesToUser(input: AddRolesToUserInput!): User!
  createManyFiles(input: CreateManyFilesInput!): [File!]!
  createManyInventories(input: CreateManyInventoriesInput!): [Inventory!]!
  createManyNotifications(input: CreateManyNotificationsInput!): [Notification!]!
  createManyProductions(input: CreateManyProductionsInput!): [Production!]!
  createManyStorages(input: CreateManyStoragesInput!): [Storage!]!
  createManyTasks(input: CreateManyTasksInput!): [Task!]!
  createManyUsers(input: CreateManyUsersInput!): [User!]!
  createOneField(data: CreateFieldInput!, fieldImage: Upload): Field!
  createOneFile(input: CreateOneFileInput!): File!
  createOneInventory(input: CreateOneInventoryInput!): Inventory!
  createOneNotification(input: CreateOneNotificationInput!): Notification!
  createOneProduction(input: CreateOneProductionInput!): Production!
  createOneStorage(input: CreateOneStorageInput!): Storage!
  createOneTask(input: CreateOneTaskInput!): Task!
  createOneUser(input: CreateOneUserInput!): User!
  deleteManyFiles(input: DeleteManyFilesInput!): DeleteManyResponse!
  deleteManyInventories(input: DeleteManyInventoriesInput!): DeleteManyResponse!
  deleteManyNotifications(input: DeleteManyNotificationsInput!): DeleteManyResponse!
  deleteManyProductions(input: DeleteManyProductionsInput!): DeleteManyResponse!
  deleteManyStorages(input: DeleteManyStoragesInput!): DeleteManyResponse!
  deleteManyTasks(input: DeleteManyTasksInput!): DeleteManyResponse!
  deleteManyUsers(input: DeleteManyUsersInput!): DeleteManyResponse!
  deleteOneFieldAndForget(id: String!): Field!
  deleteOneFile(input: DeleteOneFileInput!): FileDeleteResponse!
  deleteOneInventory(input: DeleteOneInventoryInput!): InventoryDeleteResponse!
  deleteOneNotification(input: DeleteOneNotificationInput!): NotificationDeleteResponse!
  deleteOneProduction(input: DeleteOneProductionInput!): ProductionDeleteResponse!
  deleteOneStorage(input: DeleteOneStorageInput!): StorageDeleteResponse!
  deleteOneTask(input: DeleteOneTaskInput!): TaskDeleteResponse!
  deleteOneUser(input: DeleteOneUserInput!): UserDeleteResponse!
  deletePhysicalFile(id: String!): Boolean!
  loginUser(data: AuthInput!): AuthType!
  removeFieldImageFromField(input: RemoveFieldImageFromFieldInput!): Field!
  removeFieldsFromInventory(input: RemoveFieldsFromInventoryInput!): Inventory!
  removeFieldsFromProduction(input: RemoveFieldsFromProductionInput!): Production!
  removeInventoriesFromField(input: RemoveInventoriesFromFieldInput!): Field!
  removeInventoriesFromStorage(input: RemoveInventoriesFromStorageInput!): Storage!
  removeNotificationsFromUser(input: RemoveNotificationsFromUserInput!): User!
  removeProductionsFromField(input: RemoveProductionsFromFieldInput!): Field!
  removeRolesFromUser(input: RemoveRolesFromUserInput!): User!
  removeStoragesFromInventory(input: RemoveStoragesFromInventoryInput!): Inventory!
  setFieldImageOnField(input: SetFieldImageOnFieldInput!): Field!
  setFieldsOnInventory(input: SetFieldsOnInventoryInput!): Inventory!
  setFieldsOnProduction(input: SetFieldsOnProductionInput!): Production!
  setInventoriesOnField(input: SetInventoriesOnFieldInput!): Field!
  setInventoriesOnStorage(input: SetInventoriesOnStorageInput!): Storage!
  setNotificationsOnUser(input: SetNotificationsOnUserInput!): User!
  setProductionsOnField(input: SetProductionsOnFieldInput!): Field!
  setRolesOnUser(input: SetRolesOnUserInput!): User!
  setStoragesOnInventory(input: SetStoragesOnInventoryInput!): Inventory!
  updateManyFiles(input: UpdateManyFilesInput!): UpdateManyResponse!
  updateManyInventories(input: UpdateManyInventoriesInput!): UpdateManyResponse!
  updateManyNotifications(input: UpdateManyNotificationsInput!): UpdateManyResponse!
  updateManyProductions(input: UpdateManyProductionsInput!): UpdateManyResponse!
  updateManyStorages(input: UpdateManyStoragesInput!): UpdateManyResponse!
  updateManyTasks(input: UpdateManyTasksInput!): UpdateManyResponse!
  updateManyUsers(input: UpdateManyUsersInput!): UpdateManyResponse!
  updateOneField(data: UpdateFieldInput!, fieldImage: Upload, id: String!): Field!
  updateOneFile(input: UpdateOneFileInput!): File!
  updateOneInventory(input: UpdateOneInventoryInput!): Inventory!
  updateOneNotification(input: UpdateOneNotificationInput!): Notification!
  updateOneProduction(input: UpdateOneProductionInput!): Production!
  updateOneStorage(input: UpdateOneStorageInput!): Storage!
  updateOneTask(input: UpdateOneTaskInput!): Task!
  updateOneUser(input: UpdateOneUserInput!): User!
}

type Notification {
  description: String!
  id: String!
  title: String!
  userId: String!
}

type NotificationAggregateGroupBy {
  description: String
  id: String
  title: String
  userId: String
}

type NotificationConnection {
  """Array of nodes."""
  nodes: [Notification!]!

  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type NotificationCountAggregate {
  description: Int
  id: Int
  title: Int
  userId: Int
}

input NotificationDeleteFilter {
  and: [NotificationDeleteFilter!]
  description: StringFieldComparison
  id: StringFieldComparison
  or: [NotificationDeleteFilter!]
  title: StringFieldComparison
  userId: StringFieldComparison
}

type NotificationDeleteResponse {
  description: String
  id: String
  title: String
  userId: String
}

input NotificationFilter {
  and: [NotificationFilter!]
  description: StringFieldComparison
  id: StringFieldComparison
  or: [NotificationFilter!]
  title: StringFieldComparison
  userId: StringFieldComparison
}

type NotificationMaxAggregate {
  description: String
  id: String
  title: String
  userId: String
}

type NotificationMinAggregate {
  description: String
  id: String
  title: String
  userId: String
}

input NotificationSort {
  direction: SortDirection!
  field: NotificationSortFields!
  nulls: SortNulls
}

enum NotificationSortFields {
  description
  id
  title
  userId
}

input NotificationUpdateFilter {
  and: [NotificationUpdateFilter!]
  description: StringFieldComparison
  id: StringFieldComparison
  or: [NotificationUpdateFilter!]
  title: StringFieldComparison
  userId: StringFieldComparison
}

input NumberFieldComparison {
  between: NumberFieldComparisonBetween
  eq: Float
  gt: Float
  gte: Float
  in: [Float!]
  is: Boolean
  isNot: Boolean
  lt: Float
  lte: Float
  neq: Float
  notBetween: NumberFieldComparisonBetween
  notIn: [Float!]
}

input NumberFieldComparisonBetween {
  lower: Float!
  upper: Float!
}

type OffsetPageInfo {
  """true if paging forward and there are more records."""
  hasNextPage: Boolean

  """true if paging backwards and there are more records."""
  hasPreviousPage: Boolean
}

input OffsetPaging {
  """Limit the number of records returned"""
  limit: Int

  """Offset to start returning records from"""
  offset: Int
}

type Production {
  amount: Float!
  createdAt: DateTime!
  deletedAt: DateTime!
  fields: Field
  id: String!
  name: String!
  updatedAt: DateTime!
}

type ProductionAggregateGroupBy {
  amount: Float
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  name: String
  updatedAt: DateTime
}

type ProductionAvgAggregate {
  amount: Float
}

type ProductionConnection {
  """Array of nodes."""
  nodes: [Production!]!

  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type ProductionCountAggregate {
  amount: Int
  createdAt: Int
  deletedAt: Int
  id: Int
  name: Int
  updatedAt: Int
}

input ProductionDeleteFilter {
  amount: NumberFieldComparison
  and: [ProductionDeleteFilter!]
  createdAt: DateFieldComparison
  deletedAt: DateFieldComparison
  id: StringFieldComparison
  name: StringFieldComparison
  or: [ProductionDeleteFilter!]
  updatedAt: DateFieldComparison
}

type ProductionDeleteResponse {
  amount: Float
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  name: String
  updatedAt: DateTime
}

input ProductionFilter {
  amount: NumberFieldComparison
  and: [ProductionFilter!]
  createdAt: DateFieldComparison
  deletedAt: DateFieldComparison
  fields: ProductionFilterFieldFilter
  id: StringFieldComparison
  name: StringFieldComparison
  or: [ProductionFilter!]
  updatedAt: DateFieldComparison
}

input ProductionFilterFieldFilter {
  acre: StringFieldComparison
  and: [ProductionFilterFieldFilter!]
  cordinates: StringFieldComparison
  createdAt: DateFieldComparison
  deletedAt: DateFieldComparison
  id: StringFieldComparison
  imagePath: StringFieldComparison
  name: StringFieldComparison
  or: [ProductionFilterFieldFilter!]
  updatedAt: DateFieldComparison
}

type ProductionMaxAggregate {
  amount: Float
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  name: String
  updatedAt: DateTime
}

type ProductionMinAggregate {
  amount: Float
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  name: String
  updatedAt: DateTime
}

input ProductionSort {
  direction: SortDirection!
  field: ProductionSortFields!
  nulls: SortNulls
}

enum ProductionSortFields {
  amount
  createdAt
  deletedAt
  id
  name
  updatedAt
}

type ProductionSumAggregate {
  amount: Float
}

input ProductionUpdateFilter {
  amount: NumberFieldComparison
  and: [ProductionUpdateFilter!]
  createdAt: DateFieldComparison
  deletedAt: DateFieldComparison
  id: StringFieldComparison
  name: StringFieldComparison
  or: [ProductionUpdateFilter!]
  updatedAt: DateFieldComparison
}

type Query {
  field(
    """The id of the record to find."""
    id: ID!
  ): Field
  fieldAggregate(
    """Filter to find records to aggregate on"""
    filter: FieldAggregateFilter
  ): [FieldAggregateResponse!]!
  fields(
    """Specify to filter the records returned."""
    filter: FieldFilter! = {}

    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to sort results."""
    sorting: [FieldSort!]! = []
  ): FieldConnection!
  file(
    """The id of the record to find."""
    id: ID!
  ): File
  files(
    """Specify to filter the records returned."""
    filter: FileFilter! = {}

    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to sort results."""
    sorting: [FileSort!]! = []
  ): FileConnection!
  getOneUser(id: String!): User!
  getUserByEmail(email: String): User!
  inventories(
    """Specify to filter the records returned."""
    filter: InventoryFilter! = {}

    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to sort results."""
    sorting: [InventorySort!]! = []
  ): InventoryConnection!
  inventory(
    """The id of the record to find."""
    id: ID!
  ): Inventory
  me: User!
  notification(
    """The id of the record to find."""
    id: ID!
  ): Notification
  notifications(
    """Specify to filter the records returned."""
    filter: NotificationFilter! = {}

    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to sort results."""
    sorting: [NotificationSort!]! = []
  ): NotificationConnection!
  production(
    """The id of the record to find."""
    id: ID!
  ): Production
  productions(
    """Specify to filter the records returned."""
    filter: ProductionFilter! = {}

    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to sort results."""
    sorting: [ProductionSort!]! = []
  ): ProductionConnection!
  role(
    """The id of the record to find."""
    id: ID!
  ): Role
  roles(
    """Specify to filter the records returned."""
    filter: RoleFilter! = {}

    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to sort results."""
    sorting: [RoleSort!]! = []
  ): RoleConnection!
  storage(
    """The id of the record to find."""
    id: ID!
  ): Storage
  storages(
    """Specify to filter the records returned."""
    filter: StorageFilter! = {}

    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to sort results."""
    sorting: [StorageSort!]! = []
  ): StorageConnection!
  task(
    """The id of the record to find."""
    id: ID!
  ): Task
  tasks(
    """Specify to filter the records returned."""
    filter: TaskFilter! = {}

    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to sort results."""
    sorting: [TaskSort!]! = []
  ): TaskConnection!
  user(
    """The id of the record to find."""
    id: ID!
  ): User
  users(
    """Specify to filter the records returned."""
    filter: UserFilter! = {}

    """Limit or page results."""
    paging: OffsetPaging! = {limit: 10}

    """Specify to sort results."""
    sorting: [UserSort!]! = []
  ): UserConnection!
}

input RemoveFieldImageFromFieldInput {
  """The id of the record."""
  id: ID!

  """The id of relation."""
  relationId: ID!
}

input RemoveFieldsFromInventoryInput {
  """The id of the record."""
  id: ID!

  """The id of relation."""
  relationId: ID!
}

input RemoveFieldsFromProductionInput {
  """The id of the record."""
  id: ID!

  """The id of relation."""
  relationId: ID!
}

input RemoveInventoriesFromFieldInput {
  """The id of the record."""
  id: ID!

  """The id of relation."""
  relationId: ID!
}

input RemoveInventoriesFromStorageInput {
  """The id of the record."""
  id: ID!

  """The id of relation."""
  relationId: ID!
}

input RemoveNotificationsFromUserInput {
  """The id of the record."""
  id: ID!

  """The ids of the relations."""
  relationIds: [ID!]!
}

input RemoveProductionsFromFieldInput {
  """The id of the record."""
  id: ID!

  """The id of relation."""
  relationId: ID!
}

input RemoveRolesFromUserInput {
  """The id of the record."""
  id: ID!

  """The ids of the relations."""
  relationIds: [ID!]!
}

input RemoveStoragesFromInventoryInput {
  """The id of the record."""
  id: ID!

  """The id of relation."""
  relationId: ID!
}

type Role {
  createdAt: DateTime!
  deletedAt: DateTime!
  id: String!
  name: RolesEnum!
  updatedAt: DateTime!
}

type RoleAggregateGroupBy {
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  name: RolesEnum
  updatedAt: DateTime
}

type RoleConnection {
  """Array of nodes."""
  nodes: [Role!]!

  """Paging information"""
  pageInfo: OffsetPageInfo!
}

type RoleCountAggregate {
  createdAt: Int
  deletedAt: Int
  id: Int
  name: Int
  updatedAt: Int
}

input RoleFilter {
  and: [RoleFilter!]
  createdAt: DateFieldComparison
  deletedAt: DateFieldComparison
  id: StringFieldComparison
  name: RolesEnumFilterComparison
  or: [RoleFilter!]
  updatedAt: DateFieldComparison
}

input RoleInput {
  id: String!
  name: RolesEnum
}

type RoleInputDTO {
  id: String!
  name: RolesEnum
}

input RoleInputDTOFilter {
  and: [RoleInputDTOFilter!]
  name: RolesEnumFilterComparison
  or: [RoleInputDTOFilter!]
}

input RoleInputDTOSort {
  direction: SortDirection!
  field: RoleInputDTOSortFields!
  nulls: SortNulls
}

enum RoleInputDTOSortFields {
  name
}

type RoleMaxAggregate {
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  name: RolesEnum
  updatedAt: DateTime
}

type RoleMinAggregate {
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  name: RolesEnum
  updatedAt: DateTime
}

input RoleSort {
  direction: SortDirection!
  field: RoleSortFields!
  nulls: SortNulls
}

enum RoleSortFields {
  createdAt
  deletedAt
  id
  name
  updatedAt
}

enum RolesEnum {
  EMPLOYEE
  SUPER_ADMIN
}

input RolesEnumFilterComparison {
  eq: RolesEnum
  gt: RolesEnum
  gte: RolesEnum
  iLike: RolesEnum
  in: [RolesEnum!]
  is: Boolean
  isNot: Boolean
  like: RolesEnum
  lt: RolesEnum
  lte: RolesEnum
  neq: RolesEnum
  notILike: RolesEnum
  notIn: [RolesEnum!]
  notLike: RolesEnum
}

input SetFieldImageOnFieldInput {
  """The id of the record."""
  id: ID!

  """The id of relation."""
  relationId: ID!
}

input SetFieldsOnInventoryInput {
  """The id of the record."""
  id: ID!

  """The id of relation."""
  relationId: ID!
}

input SetFieldsOnProductionInput {
  """The id of the record."""
  id: ID!

  """The id of relation."""
  relationId: ID!
}

input SetInventoriesOnFieldInput {
  """The id of the record."""
  id: ID!

  """The id of relation."""
  relationId: ID!
}

input SetInventoriesOnStorageInput {
  """The id of the record."""
  id: ID!

  """The id of relation."""
  relationId: ID!
}

input SetNotificationsOnUserInput {
  """The id of the record."""
  id: ID!

  """The ids of the relations."""
  relationIds: [ID!]!
}

input SetProductionsOnFieldInput {
  """The id of the record."""
  id: ID!

  """The id of relation."""
  relationId: ID!
}

input SetRolesOnUserInput {
  """The id of the record."""
  id: ID!

  """The ids of the relations."""
  relationIds: [ID!]!
}

input SetStoragesOnInventoryInput {
  """The id of the record."""
  id: ID!

  """The id of relation."""
  relationId: ID!
}

"""Sort Directions"""
enum SortDirection {
  ASC
  DESC
}

"""Sort Nulls Options"""
enum SortNulls {
  NULLS_FIRST
  NULLS_LAST
}

type Storage {
  amount: Float!
  createdAt: DateTime!
  deletedAt: DateTime!
  id: String!
  inventories: Inventory
  name: String!
  updatedAt: DateTime!
}

type StorageAggregateGroupBy {
  amount: Float
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  name: String
  updatedAt: DateTime
}

type StorageAvgAggregate {
  amount: Float
}

type StorageConnection {
  """Array of nodes."""
  nodes: [Storage!]!

  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type StorageCountAggregate {
  amount: Int
  createdAt: Int
  deletedAt: Int
  id: Int
  name: Int
  updatedAt: Int
}

input StorageDeleteFilter {
  amount: NumberFieldComparison
  and: [StorageDeleteFilter!]
  createdAt: DateFieldComparison
  deletedAt: DateFieldComparison
  id: StringFieldComparison
  name: StringFieldComparison
  or: [StorageDeleteFilter!]
  updatedAt: DateFieldComparison
}

type StorageDeleteResponse {
  amount: Float
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  name: String
  updatedAt: DateTime
}

input StorageFilter {
  amount: NumberFieldComparison
  and: [StorageFilter!]
  createdAt: DateFieldComparison
  deletedAt: DateFieldComparison
  id: StringFieldComparison
  inventories: StorageFilterInventoryFilter
  name: StringFieldComparison
  or: [StorageFilter!]
  updatedAt: DateFieldComparison
}

input StorageFilterInventoryFilter {
  amount: NumberFieldComparison
  and: [StorageFilterInventoryFilter!]
  createdAt: DateFieldComparison
  deletedAt: DateFieldComparison
  id: StringFieldComparison
  name: StringFieldComparison
  or: [StorageFilterInventoryFilter!]
  provider: StringFieldComparison
  storage: StringFieldComparison
  updatedAt: DateFieldComparison
  value: NumberFieldComparison
}

type StorageMaxAggregate {
  amount: Float
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  name: String
  updatedAt: DateTime
}

type StorageMinAggregate {
  amount: Float
  createdAt: DateTime
  deletedAt: DateTime
  id: String
  name: String
  updatedAt: DateTime
}

input StorageSort {
  direction: SortDirection!
  field: StorageSortFields!
  nulls: SortNulls
}

enum StorageSortFields {
  amount
  createdAt
  deletedAt
  id
  name
  updatedAt
}

type StorageSumAggregate {
  amount: Float
}

input StorageUpdateFilter {
  amount: NumberFieldComparison
  and: [StorageUpdateFilter!]
  createdAt: DateFieldComparison
  deletedAt: DateFieldComparison
  id: StringFieldComparison
  name: StringFieldComparison
  or: [StorageUpdateFilter!]
  updatedAt: DateFieldComparison
}

input StringFieldComparison {
  eq: String
  gt: String
  gte: String
  iLike: String
  in: [String!]
  is: Boolean
  isNot: Boolean
  like: String
  lt: String
  lte: String
  neq: String
  notILike: String
  notIn: [String!]
  notLike: String
}

type Subscription {
  createdField(input: CreateFieldSubscriptionFilterInput): Field!
  deletedManyFields: DeleteManyResponse!
  deletedOneField(input: DeleteOneFieldSubscriptionFilterInput): FieldDeleteResponse!
  updatedManyFields: UpdateManyResponse!
  updatedOneField(input: UpdateOneFieldSubscriptionFilterInput): Field!
}

type Task {
  createdAt: DateTime!
  date: DateTime!
  dayOfWeek: Float
  deletedAt: DateTime!
  description: String!
  id: String!
  title: String!
  updatedAt: DateTime!
  userName: String
}

type TaskAggregateGroupBy {
  createdAt: DateTime
  date: DateTime
  dayOfWeek: Float
  deletedAt: DateTime
  description: String
  id: String
  title: String
  updatedAt: DateTime
  userName: String
}

type TaskAvgAggregate {
  dayOfWeek: Float
}

type TaskConnection {
  """Array of nodes."""
  nodes: [Task!]!

  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type TaskCountAggregate {
  createdAt: Int
  date: Int
  dayOfWeek: Int
  deletedAt: Int
  description: Int
  id: Int
  title: Int
  updatedAt: Int
  userName: Int
}

input TaskDeleteFilter {
  and: [TaskDeleteFilter!]
  createdAt: DateFieldComparison
  date: DateFieldComparison
  dayOfWeek: NumberFieldComparison
  deletedAt: DateFieldComparison
  description: StringFieldComparison
  id: StringFieldComparison
  or: [TaskDeleteFilter!]
  title: StringFieldComparison
  updatedAt: DateFieldComparison
  userName: StringFieldComparison
}

type TaskDeleteResponse {
  createdAt: DateTime
  date: DateTime
  dayOfWeek: Float
  deletedAt: DateTime
  description: String
  id: String
  title: String
  updatedAt: DateTime
  userName: String
}

input TaskFilter {
  and: [TaskFilter!]
  createdAt: DateFieldComparison
  date: DateFieldComparison
  dayOfWeek: NumberFieldComparison
  deletedAt: DateFieldComparison
  description: StringFieldComparison
  id: StringFieldComparison
  or: [TaskFilter!]
  title: StringFieldComparison
  updatedAt: DateFieldComparison
  userName: StringFieldComparison
}

type TaskMaxAggregate {
  createdAt: DateTime
  date: DateTime
  dayOfWeek: Float
  deletedAt: DateTime
  description: String
  id: String
  title: String
  updatedAt: DateTime
  userName: String
}

type TaskMinAggregate {
  createdAt: DateTime
  date: DateTime
  dayOfWeek: Float
  deletedAt: DateTime
  description: String
  id: String
  title: String
  updatedAt: DateTime
  userName: String
}

input TaskSort {
  direction: SortDirection!
  field: TaskSortFields!
  nulls: SortNulls
}

enum TaskSortFields {
  createdAt
  date
  dayOfWeek
  deletedAt
  description
  id
  title
  updatedAt
  userName
}

type TaskSumAggregate {
  dayOfWeek: Float
}

input TaskUpdateFilter {
  and: [TaskUpdateFilter!]
  createdAt: DateFieldComparison
  date: DateFieldComparison
  dayOfWeek: NumberFieldComparison
  deletedAt: DateFieldComparison
  description: StringFieldComparison
  id: StringFieldComparison
  or: [TaskUpdateFilter!]
  title: StringFieldComparison
  updatedAt: DateFieldComparison
  userName: StringFieldComparison
}

input UpdateFieldInput {
  acre: String
  cordinates: String
  id: ID
  imagePath: String
  name: String
}

input UpdateFileInput {
  fileName: String
  filePath: String
  id: ID
  name: String
  path: String
}

input UpdateInventoryInput {
  amount: Float
  fields: [UpdateFieldInput!]
  id: ID
  name: String
  provider: String
  storage: String
  storages: [UpdateStorageInput!]
  value: Float
}

input UpdateManyFilesInput {
  """Filter used to find fields to update"""
  filter: FileUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateFileInput!
}

input UpdateManyInventoriesInput {
  """Filter used to find fields to update"""
  filter: InventoryUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateInventoryInput!
}

input UpdateManyNotificationsInput {
  """Filter used to find fields to update"""
  filter: NotificationUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateNotification!
}

input UpdateManyProductionsInput {
  """Filter used to find fields to update"""
  filter: ProductionUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateProductionInput!
}

type UpdateManyResponse {
  """The number of records updated."""
  updatedCount: Int!
}

input UpdateManyStoragesInput {
  """Filter used to find fields to update"""
  filter: StorageUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateStorageInput!
}

input UpdateManyTasksInput {
  """Filter used to find fields to update"""
  filter: TaskUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateTaskInput!
}

input UpdateManyUsersInput {
  """Filter used to find fields to update"""
  filter: UserUpdateFilter!

  """The update to apply to all records found using the filter"""
  update: UpdateUserInput!
}

input UpdateNotification {
  description: String
  id: String
  title: String
  userId: String
}

input UpdateOneFieldSubscriptionFilterInput {
  """Specify to filter the records returned."""
  filter: FieldSubscriptionFilter!
}

input UpdateOneFileInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateFileInput!
}

input UpdateOneInventoryInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateInventoryInput!
}

input UpdateOneNotificationInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateNotification!
}

input UpdateOneProductionInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateProductionInput!
}

input UpdateOneStorageInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateStorageInput!
}

input UpdateOneTaskInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateTaskInput!
}

input UpdateOneUserInput {
  """The id of the record to update"""
  id: ID!

  """The update to apply."""
  update: UpdateUserInput!
}

input UpdateProductionInput {
  amount: Float
  fields: [UpdateFieldInput!]
  id: ID
  name: String
}

input UpdateStorageInput {
  amount: Float
  id: ID
  name: String
}

input UpdateTaskInput {
  date: DateTime
  dayOfWeek: Float
  description: String
  id: ID
  title: String
  userName: String
}

input UpdateUserInput {
  CPF: String
  email: String
  id: ID
  name: String
  password: String
  roles: [RoleInput!]
  telephone: String
}

"""The `Upload` scalar type represents a file upload."""
scalar Upload

type User {
  CPF: String
  email: String!
  id: String!
  name: String!
  notifications(
    """Specify to filter the records returned."""
    filter: NotificationFilter! = {}

    """Specify to sort results."""
    sorting: [NotificationSort!]! = []
  ): [Notification!]!
  roles(
    """Specify to filter the records returned."""
    filter: RoleInputDTOFilter! = {}

    """Specify to sort results."""
    sorting: [RoleInputDTOSort!]! = []
  ): [RoleInputDTO!]!
  telephone: String
}

type UserAggregateGroupBy {
  CPF: String
  email: String
  name: String
  telephone: String
}

type UserConnection {
  """Array of nodes."""
  nodes: [User!]!

  """Paging information"""
  pageInfo: OffsetPageInfo!

  """Fetch total count of records"""
  totalCount: Int!
}

type UserCountAggregate {
  CPF: Int
  email: Int
  name: Int
  telephone: Int
}

input UserDeleteFilter {
  CPF: StringFieldComparison
  and: [UserDeleteFilter!]
  email: StringFieldComparison
  name: StringFieldComparison
  or: [UserDeleteFilter!]
  telephone: StringFieldComparison
}

type UserDeleteResponse {
  CPF: String
  email: String
  id: String
  name: String
  telephone: String
}

input UserFilter {
  CPF: StringFieldComparison
  and: [UserFilter!]
  email: StringFieldComparison
  name: StringFieldComparison
  notifications: UserFilterNotificationFilter
  or: [UserFilter!]
  roles: UserFilterRoleInputDTOFilter
  telephone: StringFieldComparison
}

input UserFilterNotificationFilter {
  and: [UserFilterNotificationFilter!]
  description: StringFieldComparison
  id: StringFieldComparison
  or: [UserFilterNotificationFilter!]
  title: StringFieldComparison
  userId: StringFieldComparison
}

input UserFilterRoleInputDTOFilter {
  and: [UserFilterRoleInputDTOFilter!]
  name: RolesEnumFilterComparison
  or: [UserFilterRoleInputDTOFilter!]
}

type UserMaxAggregate {
  CPF: String
  email: String
  name: String
  telephone: String
}

type UserMinAggregate {
  CPF: String
  email: String
  name: String
  telephone: String
}

input UserSort {
  direction: SortDirection!
  field: UserSortFields!
  nulls: SortNulls
}

enum UserSortFields {
  CPF
  email
  name
  telephone
}

input UserUpdateFilter {
  CPF: StringFieldComparison
  and: [UserUpdateFilter!]
  email: StringFieldComparison
  name: StringFieldComparison
  or: [UserUpdateFilter!]
  telephone: StringFieldComparison
}